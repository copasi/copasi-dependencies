//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 4.0.2
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace libsbml {

 using System;
 using System.Runtime.InteropServices;

/** 
 * @sbmlpackage{core}
 *
@htmlinclude pkg-marker-core.html Abstract Syntax Tree (AST) representation of a
 * mathematical expression.
 *
 * @htmlinclude not-sbml-warning.html
 *
 * Abstract Syntax Trees (ASTs) are a simple kind of data structure used in
 * libSBML for storing mathematical expressions.  The ASTNode is the
 * cornerstone of libSBML's AST representation.  An AST 'node' represents the
 * most basic, indivisible part of a mathematical formula and come in many
 * types.  For instance, there are node types to represent numbers (with
 * subtypes to distinguish integer, real, and rational numbers), names
 * (e.g., constants or variables), simple mathematical operators, logical
 * or relational operators and functions. LibSBML ASTs provide a canonical,
 * in-memory representation for all mathematical formulas regardless of
 * their original format (which might be MathML or might be text strings).
 *
 *
 * 
 * An AST @em node in libSBML is a recursive tree structure; each node has a
 * type, a pointer to a value, and a list of children nodes.  Each ASTNode
 * node may have none, one, two, or more children depending on its type.
 * There are node types to represent numbers (with subtypes to distinguish
 * integer, real, and rational numbers), names (e.g., constants or
 * variables), simple mathematical operators, logical or relational operators
 * and functions.  The following diagram illustrates an example of how the
 * mathematical expression <code>'1 + 2'</code> is represented as an AST with
 * one @em plus node having two @em integer children nodes for the numbers
 * <code>1</code> and <code>2</code>.  The figure also shows the
 * corresponding MathML representation:
 *
 * @htmlinclude astnode-illustration.html
 *
 * The following are other noteworthy points about the AST representation
 * in libSBML:

 * @li A numerical value represented in MathML as a real number with an
 * exponent is preserved as such in the AST node representation, even if the
 * number could be stored in a @c double data type.  This is done so that
 * when an SBML model is read in and then written out again, the amount of
 * change introduced by libSBML to the SBML during the round-trip activity is
 * minimized.
 *
 * @li Rational numbers are represented in an AST node using separate
 * numerator and denominator values.  These can be retrieved using the
 * methods ASTNode::getNumerator() and ASTNode::getDenominator().
 *
 * @li The children of an ASTNode are other ASTNode objects.  The list of
 * children is empty for nodes that are leaf elements, such as numbers.
 * For nodes that are actually roots of expression subtrees, the list of
 * children points to the parsed objects that make up the rest of the
 * expression.
 *
 * For many applications, the details of ASTs are irrelevant because libSBML
 * provides text-string based translation functions such as
 * @sbmlfunction{formulaToL3String, ASTNode} and
 * @sbmlfunction{parseL3Formula, String}.  If you find the complexity
 * of using the AST representation of expressions too high for your purposes,
 * perhaps the string-based functions will be more suitable.
 *
 *
 *
 * @if clike <h3><a class='anchor' name='ASTNodeType_t'>
 * ASTNodeType_t</a></h3> @else <h3><a class='anchor'
 * name='ASTNodeType_t'>The set of possible %ASTNode types</a></h3> @endif
 *
 *
 * 
 * Every ASTNode has an associated type code to indicate whether, for
 * example, it holds a number or stands for an arithmetic operator.
 * @if clike The type is recorded as a value drawn from the enumeration
 * #ASTNodeType_t.@endif
 * @if java The type is recorded as a value drawn from a
 * set of static integer constants defined in the class @link
 * libsbml.libsbml@endlink. Their names begin with the characters @c AST_.@endif
 * @if python The type is recorded as a value drawn from a
 * set of static integer constants defined in the class @link
 * libsbml@endlink. Their names begin with the characters @c AST_.@endif
 * @if csharp The type is recorded as a value drawn from a
 * set of static integer constants defined in the class @link
 * libsbml@endlink. Their names begin with the characters @c AST_.@endif
 * The list of possible types is quite long, because it covers all the
 * mathematical functions that are permitted in SBML. The values are shown
 * in the following table:
 *
 * @htmlinclude astnode-types.html
 *
 * The types have the following meanings:
 *
 * @li If the node is basic mathematical operator (e.g., @c '+'), then the
 * node's type will be @link libsbml#AST_PLUS AST_PLUS@endlink,
 * @link libsbml#AST_MINUS AST_MINUS@endlink,
 * @link libsbml#AST_TIMES AST_TIMES@endlink,
 * @link libsbml#AST_DIVIDE AST_DIVIDE@endlink, or
 * @link libsbml#AST_POWER AST_POWER@endlink, as appropriate.
 *
 * @li If the node is a predefined function or operator from %SBML
 * Level&nbsp;1 (in the string-based formula syntax used in Level&nbsp;1) or
 * %SBML Level&nbsp;2 and&nbsp;3 (in the subset of MathML used in SBML
 * Levels&nbsp;2 and&nbsp;3), then the node's type
 * will be either <code style='margin-right: 0'>AST_FUNCTION_</code><span
 * class='placeholder-nospace'>X</span>, <code style='margin-right: 0'>AST_LOGICAL_</code><span
 * class='placeholder-nospace'>X</span>, or <code style='margin-right: 0'>AST_RELATIONAL_</code><span
 * class='placeholder-nospace'>X</span>, as appropriate.  (Examples:
 * @link libsbml#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink,
 * @link libsbml#AST_RELATIONAL_LEQ AST_RELATIONAL_LEQ@endlink.)
 *
 * @li If the node refers to a user-defined function, the node's type will
 * be @link libsbml#AST_FUNCTION AST_FUNCTION@endlink (because it holds the
 * name of the function).
 *
 * @li If the node is a lambda expression, its type will be
 * @link libsbml#AST_LAMBDA AST_LAMBDA@endlink.
 *
 * @li If the node is a predefined constant (@c 'ExponentialE', @c 'Pi',
 * @c 'True' or @c 'False'), then the node's type will be
 * @link libsbml#AST_CONSTANT_E AST_CONSTANT_E@endlink,
 * @link libsbml#AST_CONSTANT_PI AST_CONSTANT_PI@endlink,
 * @link libsbml#AST_CONSTANT_TRUE AST_CONSTANT_TRUE@endlink, or
 * @link libsbml#AST_CONSTANT_FALSE AST_CONSTANT_FALSE@endlink.
 *
 * @li (Levels&nbsp;2 and&nbsp;3 only) If the node is the special MathML
 * csymbol @c time, the value of the node will be
 * @link libsbml#AST_NAME_TIME AST_NAME_TIME@endlink.  (Note, however, that the
 * MathML csymbol @c delay is translated into a node of type
 * @link libsbml#AST_FUNCTION_DELAY AST_FUNCTION_DELAY@endlink.  The difference is due to
 * the fact that @c time is a single variable, whereas @c delay is actually a
 * function taking arguments.)
 *
 * @li (Level&nbsp;3 only) If the node is the special MathML csymbol
 * @c avogadro, the value of the node will be
 * @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.
 *
 * @li (Level&nbsp;3 Version&nbsp;2+ only) If the node is the special MathML
 * csymbol @c rateOf, the value of the node will be
 * @link libsbml#AST_FUNCTION_RATE_OF AST_FUNCTION_RATE_OF@endlink.
 *
 * @li (Level&nbsp;3 Version&nbsp;2+ only) If the node is a MathML 
 * operator that originates in a package, it is included in the
 * ASTNodeType_t list, but may not be legally used in an SBML document
 * that does not include that package.  This includes the node types from
 * the 'Distributions' package (@link libsbml#AST_DISTRIB_FUNCTION_NORMAL AST_DISTRIB_FUNCTION_NORMAL@endlink, @link libsbml#AST_DISTRIB_FUNCTION_UNIFORM AST_DISTRIB_FUNCTION_UNIFORM@endlink,
 * etc.), and elements from MathML that were not included in core.
 *
 * @li If the node contains a numerical value, its type will be
 * @link libsbml#AST_INTEGER AST_INTEGER@endlink,
 * @link libsbml#AST_REAL AST_REAL@endlink,
 * @link libsbml#AST_REAL_E AST_REAL_E@endlink, or
 * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, as appropriate.
 *
 *
 *
 * <h3><a class='anchor' name='math-convert'>Converting between ASTs and text strings</a></h3>
 *
 * The text-string form of mathematical formulas produced by 
 * @sbmlfunction{formulaToString,ASTNode_t} and @sbmlfunction{formulaToL3String,ASTNode_t}, 
 * and read by @sbmlfunction{parseFormula,String} and @sbmlfunction{parseL3Formula,String}
 * are in a simple C-inspired infix notation.  A
 * formula in this text-string form can be handed to a program that
 * understands SBML mathematical expressions, or used as part
 * of a translation system.  The libSBML distribution comes with an example
 * program in the @c 'examples' subdirectory called @c translateMath that
 * implements an interactive command-line demonstration of translating
 * infix formulas into MathML and vice-versa.
 *
 * The formula strings may contain operators, function calls, symbols, and
 * white space characters.  The allowable white space characters are tab
 * and space.  The following are illustrative examples of formulas
 * expressed in the syntax:
 * 
 * @verbatim
0.10 * k4^2
@endverbatim
 * @verbatim
(vm * s1)/(km + s1)
@endverbatim
 *
 * The following table shows the precedence rules in this syntax.  In the
 * Class column, @em operand implies the construct is an operand, @em
 * prefix implies the operation is applied to the following arguments, @em
 * unary implies there is one argument, and @em binary implies there are
 * two arguments.  The values in the Precedence column show how the order
 * of different types of operation are determined.  For example, the
 * expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em>
 * because the <code>*</code> operator has higher precedence.  The
 * Associates column shows how the order of similar precedence operations
 * is determined; for example, <em>a - b + c</em> is evaluated as <em>(a -
 * b) + c</em> because the <code>+</code> and <code>-</code> operators are
 * left-associative.  The precedence and associativity rules are taken from
 * the C programming language, except for the symbol <code>^</code>, which
 * is used in C for a different purpose.  (Exponentiation can be invoked
 * using either <code>^</code> or the function @c power.)
 * 
 * @htmlinclude math-precedence-table.html 
 *
 * A program parsing a formula in an SBML model should assume that names
 * appearing in the formula are the identifiers of Species, Parameter,
 * Compartment, FunctionDefinition, Reaction (in SBML Levels&nbsp;2
 * and&nbsp;3), or SpeciesReference (in SBML Level&nbsp;3 only) objects
 * defined in a model.  When a function call is involved, the syntax
 * consists of a function identifier, followed by optional white space,
 * followed by an opening parenthesis, followed by a sequence of zero or
 * more arguments separated by commas (with each comma optionally preceded
 * and/or followed by zero or more white space characters), followed by a
 * closing parenthesis.  There is an almost one-to-one mapping between the
 * list of predefined functions available, and those defined in MathML.
 * All of the MathML functions are recognized; this set is larger than the
 * functions defined in SBML Level&nbsp;1.  In the subset of functions that
 * overlap between MathML and SBML Level&nbsp;1, there exist a few
 * differences.  The following table summarizes the differences between the
 * predefined functions in SBML Level&nbsp;1 and the MathML equivalents in
 * SBML Levels&nbsp;2 and &nbsp;3:
 * 
 * @htmlinclude math-functions.html
 * 
 *
 * @note
 * Callers using SBML Level&nbsp;3 are encouraged to use the facilities
 * provided by libSBML's newer and more powerful Level&nbsp;3-oriented
 * formula parser and formatter.  The entry points to this second system are
 * @sbmlfunction{parseL3Formula, String} and
 * @sbmlfunction{formulaToL3String, ASTNode}.  The Level&nbsp;1-oriented
 * system (i.e., what is provided by @sbmlfunction{formulaToString, String}
 * and @sbmlfunction{parseFormula, ASTNode}) is provided
 * untouched for backwards compatibility.
 *
 *
 *
 * @see @sbmlfunction{parseL3Formula, String}
 * @see @sbmlfunction{parseL3FormulaWithSettings, String\, L3ParserSettings}
 * @see @sbmlfunction{parseL3FormulaWithModel, String\, Model}
 * @see @sbmlfunction{parseFormula, String}
 * @see @sbmlfunction{formulaToL3StringWithSettings, ASTNode\, L3ParserSettings}
 * @see @sbmlfunction{formulaToL3String, ASTNode}
 * @see @sbmlfunction{formulaToString, ASTNode}
 * @see @sbmlfunction{getDefaultL3ParserSettings,}
 */

public class ASTNode : global::System.IDisposable {
	private HandleRef swigCPtr;
	protected bool swigCMemOwn;
	
	internal ASTNode(IntPtr cPtr, bool cMemoryOwn)
	{
		swigCMemOwn = cMemoryOwn;
		swigCPtr    = new HandleRef(this, cPtr);
	}
	
	internal static HandleRef getCPtr(ASTNode obj)
	{
		return (obj == null) ? new HandleRef(null, IntPtr.Zero) : obj.swigCPtr;
	}
	
	internal static HandleRef getCPtrAndDisown (ASTNode obj)
	{
		HandleRef ptr = new HandleRef(null, IntPtr.Zero);
		
		if (obj != null)
		{
			ptr             = obj.swigCPtr;
			obj.swigCMemOwn = false;
		}
		
		return ptr;
	}

  ~ASTNode() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          libsbmlPINVOKE.delete_ASTNode(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public static bool operator==(ASTNode lhs, ASTNode rhs)
  {
    if((Object)lhs == (Object)rhs)
    {
      return true;
    }

    if( ((Object)lhs == null) || ((Object)rhs == null) )
    {
      return false;
    }

    return (getCPtr(lhs).Handle.ToString() == getCPtr(rhs).Handle.ToString());
  }

  public static bool operator!=(ASTNode lhs, ASTNode rhs)
  {
    return !(lhs == rhs);
  }

  public override bool Equals(Object sb)
  {
    if ( ! (sb is ASTNode) )
    {
      return false;
    }

    return this == (ASTNode)sb;
  }

  public override int GetHashCode()
  {
    return swigCPtr.Handle.ToInt32();
  }

  
/**
   * Creates and returns a new ASTNode.
   *
   * Unless the argument @p type is given, the returned node will by default
   * have a type of @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  If the type
   * isn't supplied when caling this constructor, the caller should set the
   * node type to something else as soon as possible using @if clike
   * setType()@else ASTNode::setType(int)@endif.
   *
   * @param type an optional @if clike #ASTNodeType_t@else type@endif
   * code indicating the type of node to create.
   *
   * @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif
   */ public
 ASTNode(int type) : this(libsbmlPINVOKE.new_ASTNode__SWIG_0(type), true) {
  }

  
/**
   * Creates and returns a new ASTNode.
   *
   * Unless the argument @p type is given, the returned node will by default
   * have a type of @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  If the type
   * isn't supplied when caling this constructor, the caller should set the
   * node type to something else as soon as possible using @if clike
   * setType()@else ASTNode::setType(int)@endif.
   *
   * @param type an optional @if clike #ASTNodeType_t@else type@endif
   * code indicating the type of node to create.
   *
   * @ifnot hasDefaultArgs @htmlinclude warn-default-args-in-docs.html @endif
   */ public
 ASTNode() : this(libsbmlPINVOKE.new_ASTNode__SWIG_1(), true) {
  }

  
/**
   * Copy constructor; creates a deep copy of the given ASTNode.
   *
   * @param orig the ASTNode to be copied.
   */ public
 ASTNode(ASTNode orig) : this(libsbmlPINVOKE.new_ASTNode__SWIG_2(ASTNode.getCPtr(orig)), true) {
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
  }

  
/**
   * Frees the name of this ASTNode and sets it to @c null.
   * 
   * This operation is only applicable to ASTNode objects corresponding to
   * operators, numbers, or @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  This 
   * method has no effect on other types of nodes.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
   */ public
 int freeName() {
    int ret = libsbmlPINVOKE.ASTNode_freeName(swigCPtr);
    return ret;
  }

  
/**
   * Converts this ASTNode to a canonical form and returns @c true if
   * successful, @c false otherwise.
   *
   * The rules determining the canonical form conversion are as follows:
   *
   * @li If the node type is @link libsbml#AST_NAME AST_NAME@endlink
   * and the node name matches @c 'ExponentialE', @c 'Pi', @c 'True' or @c
   * 'False' the node type is converted to the corresponding 
   * <code>AST_CONSTANT_</code><em><span class='placeholder'>X</span></em> type.
   *
   * @li If the node type is an @link libsbml#AST_FUNCTION AST_FUNCTION@endlink 
   * and the node name matches an SBML (MathML) function name, logical operator name,
   * or relational operator name, the node is converted to the corresponding
   * <code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or
   * <code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.
   *
   * SBML Level&nbsp;1 function names are searched first; thus, for
   * example, canonicalizing @c log will result in a node type of @link libsbml#AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML
   * Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)
   *
   * Sometimes, canonicalization of a node results in a structural
   * conversion of the node as a result of adding a child.  For example, a
   * node with the SBML Level&nbsp;1 function name @c sqr and a single
   * child node (the argument) will be transformed to a node of type
   * @link libsbml#AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with
   * two children.  The first child will remain unchanged, but the second
   * child will be an ASTNode of type @link libsbml#AST_INTEGER AST_INTEGER@endlink and a value of 2.  The function names that result
   * in structural changes are: @c log10, @c sqr, and @c sqrt.
   */ public
 bool canonicalize() {
    bool ret = libsbmlPINVOKE.ASTNode_canonicalize(swigCPtr);
    return ret;
  }

  
/**
   * Adds the given node as a child of this ASTNode.
   *
   * Child nodes are added in-order, from left to right.
   *
   * @param disownedChild the ASTNode instance to add.
   * @param inRead @c false by default; may be set to @c true when 
   * reading XML where there may be a lambda function with no
   * bvar arguments.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see prependChild(ASTNode disownedChild)
   * @see replaceChild(unsigned int n, ASTNode disownedChild, bool delreplaced)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   * @see removeChild(unsigned int n)
   * @see isWellFormedASTNode()
   */ public
 int addChild(ASTNode disownedChild, bool inRead) {
    int ret = libsbmlPINVOKE.ASTNode_addChild__SWIG_0(swigCPtr, ASTNode.getCPtrAndDisown(disownedChild), inRead);
    return ret;
  }

  
/**
   * Adds the given node as a child of this ASTNode.
   *
   * Child nodes are added in-order, from left to right.
   *
   * @param disownedChild the ASTNode instance to add.
   * @param inRead @c false by default; may be set to @c true when 
   * reading XML where there may be a lambda function with no
   * bvar arguments.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see prependChild(ASTNode disownedChild)
   * @see replaceChild(unsigned int n, ASTNode disownedChild, bool delreplaced)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   * @see removeChild(unsigned int n)
   * @see isWellFormedASTNode()
   */ public
 int addChild(ASTNode disownedChild) {
    int ret = libsbmlPINVOKE.ASTNode_addChild__SWIG_1(swigCPtr, ASTNode.getCPtrAndDisown(disownedChild));
    return ret;
  }

  
/**
   * Adds the given node as a child of this ASTNode.  This method adds
   * child nodes from right to left.
   *
   * @param disownedChild the ASTNode instance to add.
   * Will become a child of the parent node.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see addChild(ASTNode disownedChild)
   * @see replaceChild(unsigned int n, ASTNode disownedChild, bool delreplaced)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   * @see removeChild(unsigned int n)
   */ public
 int prependChild(ASTNode disownedChild) {
    int ret = libsbmlPINVOKE.ASTNode_prependChild(swigCPtr, ASTNode.getCPtrAndDisown(disownedChild));
    return ret;
  }

  
/**
   * Removes the nth child of this ASTNode object.
   *
   * @param n unsigned int the index of the child to remove.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see addChild(ASTNode disownedChild)
   * @see prependChild(ASTNode disownedChild)
   * @see replaceChild(unsigned int n, ASTNode disownedChild, bool delreplaced)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   */ public
 int removeChild(long n) {
    int ret = libsbmlPINVOKE.ASTNode_removeChild(swigCPtr, n);
    return ret;
  }

  
/**
   * Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.
   *
   * @param n unsigned int the index of the child to replace.
   * @param disownedChild ASTNode to replace the nth child.
   * Will become a child of the parent node.
   * @param delreplaced Boolean indicating whether to delete the replaced child.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
   * @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see addChild(ASTNode disownedChild)
   * @see prependChild(ASTNode disownedChild)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   * @see removeChild(unsigned int n)
   */ public
 int replaceChild(long n, ASTNode disownedChild, bool delreplaced) {
    int ret = libsbmlPINVOKE.ASTNode_replaceChild__SWIG_0(swigCPtr, n, ASTNode.getCPtrAndDisown(disownedChild), delreplaced);
    return ret;
  }

  
/**
   * Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.
   *
   * @param n unsigned int the index of the child to replace.
   * @param disownedChild ASTNode to replace the nth child.
   * Will become a child of the parent node.
   * @param delreplaced Boolean indicating whether to delete the replaced child.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
   * @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see addChild(ASTNode disownedChild)
   * @see prependChild(ASTNode disownedChild)
   * @see insertChild(unsigned int n, ASTNode disownedChild)
   * @see removeChild(unsigned int n)
   */ public
 int replaceChild(long n, ASTNode disownedChild) {
    int ret = libsbmlPINVOKE.ASTNode_replaceChild__SWIG_1(swigCPtr, n, ASTNode.getCPtrAndDisown(disownedChild));
    return ret;
  }

  
/**
   * Inserts the given ASTNode at point n in the list of children
   * of this ASTNode.
   *
   * @param n unsigned int the index of the ASTNode being added.
   * @param disownedChild ASTNode to insert as the nth child.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE@endlink
   * @li @link libsbml#LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT@endlink
   *
   *
 * @warning Explicitly adding, removing or replacing children of an
 * @if conly ASTNode_t structure@else ASTNode object@endif may change the
 * structure of the mathematical formula it represents, and may even render
 * the representation invalid.  Callers need to be careful to use this method
 * in the context of other operations to create complete and correct
 * formulas.  The method @if conly ASTNode_isWellFormedASTNode()@else
 * ASTNode::isWellFormedASTNode()@endif may also be useful for checking the
 * results of node modifications.
 *
   *
   * @see addChild(ASTNode disownedChild)
   * @see prependChild(ASTNode disownedChild)
   * @see replaceChild(unsigned int n, ASTNode disownedChild, bool delreplaced)
   * @see removeChild(unsigned int n)
   */ public
 int insertChild(long n, ASTNode disownedChild) {
    int ret = libsbmlPINVOKE.ASTNode_insertChild(swigCPtr, n, ASTNode.getCPtrAndDisown(disownedChild));
    return ret;
  }

  
/**
   * Creates a recursive copy of this node and all its children.
   *
   * @return a copy of this ASTNode and all its children.  The caller owns
   * the returned ASTNode and is responsible for deleting it.
   */ public
 ASTNode deepCopy() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_deepCopy(swigCPtr);
    ASTNode ret = (cPtr == global::System.IntPtr.Zero) ? null : new ASTNode(cPtr, true);
    return ret;
  }

  
/**
   * Returns the child at index n of this node.
   *
   * @param n the index of the child to get.
   *
   * @return the nth child of this ASTNode or @c null if this node has no nth
   * child (<code>n &gt; </code>
   * @if clike getNumChildren()@else ASTNode::getNumChildren()@endif
   * <code>- 1</code>).
   *
   * @see getNumChildren()
   * @see getLeftChild()
   * @see getRightChild()
   */ public
 ASTNode getChild(long n) {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_getChild(swigCPtr, n);
    ASTNode ret = (cPtr == global::System.IntPtr.Zero) ? null : new ASTNode(cPtr, false);
    return ret;
  }

  
/**
   * Returns the left child of this node.
   *
   * @return the left child of this ASTNode.  This is equivalent to calling
   * @if clike getChild()@else ASTNode::getChild(unsigned int)@endif
   * with an argument of @c 0.
   *
   * @see getNumChildren()
   * @see getChild(@if java unsigned int@endif)
   * @see getRightChild()
   */ public
 ASTNode getLeftChild() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_getLeftChild(swigCPtr);
    ASTNode ret = (cPtr == global::System.IntPtr.Zero) ? null : new ASTNode(cPtr, false);
    return ret;
  }

  
/**
   * Returns the right child of this node.
   *
   * @return the right child of this ASTNode, or @c null if this node has no
   * right child.  If
   * @if clike getNumChildren()@else ASTNode::getNumChildren()@endif
   * <code>&gt; 1</code>, then this is equivalent to:
   * @verbatim
getChild( getNumChildren() - 1 );
@endverbatim
   *
   * @see getNumChildren()
   * @see getLeftChild()
   * @see getChild(@if java unsigned int@endif)
   */ public
 ASTNode getRightChild() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_getRightChild(swigCPtr);
    ASTNode ret = (cPtr == global::System.IntPtr.Zero) ? null : new ASTNode(cPtr, false);
    return ret;
  }

  
/**
   * Returns the number of children of this node.
   *
   * @return the number of children of this ASTNode, or 0 is this node has
   * no children.
   */ public
 long getNumChildren() { return (long)libsbmlPINVOKE.ASTNode_getNumChildren(swigCPtr); }

  
/**
   * Adds the given XMLNode as a MathML <code>&lt;semantics&gt;</code>
   * element to this ASTNode.
   *
   * @htmlinclude about-semantic-annotations.html
   *
   * @param disownedAnnotation the annotation to add.
   * Will become a child of the parent node.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   *
   *
 * @note Although SBML permits the use of the MathML
 * <code>&lt;semantics&gt;</code> annotation construct, the truth is that
 * this construct has so far (at this time of this writing, which is early
 * 2014) seen very little use in SBML software.  The full implications of
 * using these annotations are still poorly understood.  If you wish to
 * use this construct, we urge you to discuss possible uses and applications
 * on the SBML discussion lists, particularly <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-interoperability</a>.
   *
   * @see getNumSemanticsAnnotations()
   * @see getSemanticsAnnotation(@if java unsigned int@endif)
   */ public
 int addSemanticsAnnotation(XMLNode disownedAnnotation) {
    int ret = libsbmlPINVOKE.ASTNode_addSemanticsAnnotation(swigCPtr, XMLNode.getCPtrAndDisown(disownedAnnotation));
    return ret;
  }

  
/**
   * Returns the number of MathML <code>&lt;semantics&gt;</code> element
   * elements on this node.
   *
   * @htmlinclude about-semantic-annotations.html
   * 
   * @return the number of annotations of this ASTNode.
   *
   *
 * @note Although SBML permits the use of the MathML
 * <code>&lt;semantics&gt;</code> annotation construct, the truth is that
 * this construct has so far (at this time of this writing, which is early
 * 2014) seen very little use in SBML software.  The full implications of
 * using these annotations are still poorly understood.  If you wish to
 * use this construct, we urge you to discuss possible uses and applications
 * on the SBML discussion lists, particularly <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-interoperability</a>.
   *
   * @see addSemanticsAnnotation(@if java XMLNode@endif)
   * @see getSemanticsAnnotation(@if java unsigned int@endif)
   */ public
 long getNumSemanticsAnnotations() { return (long)libsbmlPINVOKE.ASTNode_getNumSemanticsAnnotations(swigCPtr); }

  
/**
   * Returns the nth MathML <code>&lt;semantics&gt;</code> element on this
   * ASTNode.
   *
   * @htmlinclude about-semantic-annotations.html
   * 
   * @param n the index of the annotation to return.  Callers should
   * use ASTNode::getNumSemanticsAnnotations() to first find out how
   * many annotations there are.
   *
   * @return the nth annotation inside this ASTNode, or @c null if this node has
   * no nth annotation (<code>n &gt;</code>
   * @if clike getNumSemanticsAnnotations()@else ASTNode::getNumSemanticsAnnotations()@endif
   * <code>- 1</code>).
   *
   *
 * @note Although SBML permits the use of the MathML
 * <code>&lt;semantics&gt;</code> annotation construct, the truth is that
 * this construct has so far (at this time of this writing, which is early
 * 2014) seen very little use in SBML software.  The full implications of
 * using these annotations are still poorly understood.  If you wish to
 * use this construct, we urge you to discuss possible uses and applications
 * on the SBML discussion lists, particularly <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-discuss</a> and/or <a target='_blank'
 * href='http://sbml.org/Forums'>sbml-interoperability</a>.
   *
   * @see getNumSemanticsAnnotations()
   * @see addSemanticsAnnotation(@if java XMLNode@endif)
   */ public
 XMLNode getSemanticsAnnotation(long n) {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_getSemanticsAnnotation(swigCPtr, n);
    XMLNode ret = (cPtr == global::System.IntPtr.Zero) ? null : new XMLNode(cPtr, false);
    return ret;
  }

  
/**
   * Returns the value of this node as a single character.
   *
   * This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_PLUS AST_PLUS@endlink,
   * @link libsbml#AST_MINUS AST_MINUS@endlink,
   * @link libsbml#AST_TIMES AST_TIMES@endlink,
   * @link libsbml#AST_DIVIDE AST_DIVIDE@endlink or
   * @link libsbml#AST_POWER AST_POWER@endlink.
   *
   * @return the value of this ASTNode as a single character
   */ public
 char getCharacter() {
    char ret = libsbmlPINVOKE.ASTNode_getCharacter(swigCPtr);
    return ret;
  }

  
/**
   * Returns the MathML @c id attribute value of this ASTNode.
   *
   * @return the MathML id of this ASTNode.
   *
   * @see isSetId()
   * @see setId(string id)
   * @see unsetId()
   */ public
 string getId() {
    string ret = libsbmlPINVOKE.ASTNode_getId(swigCPtr);
    return ret;
  }

  
/**
   * Returns the MathML @c class attribute value of this ASTNode.
   *
   * @return the MathML class of this ASTNode, or an empty string if it does not exist.
   *
   * @see isSetClass()
   * @see @if java setClassName(string id)@else setClass()@endif
   * @see unsetClass()
   */ public
 string getClass() {
    string ret = libsbmlPINVOKE.ASTNode_getClass(swigCPtr);
    return ret;
  }

  
/**
   * Returns the MathML @c style attribute value of this ASTNode.
   *
   * @return the MathML style of this ASTNode, or an empty string if it does not exist.
   *
   * @see isSetStyle()
   * @see setStyle(string id)
   * @see unsetStyle()
   */ public
 string getStyle() {
    string ret = libsbmlPINVOKE.ASTNode_getStyle(swigCPtr);
    return ret;
  }

  
/**
   * Returns the value of this node as an integer.
   *
   * If this node type is @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, this
   * method returns the value of the numerator.
   *
   * @return the value of this ASTNode as a (<code>long</code>) integer if type @link libsbml#AST_INTEGER AST_INTEGER@endlink; the numerator if type @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, and @c 0 otherwise.
   *
   * @note This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_INTEGER AST_INTEGER@endlink or
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
   * It will return @c 0 if the node type is @em not one of these, but since
   * @c 0 may be a valid value for integer, it is important to be sure that
   * the node type is one of the expected types in order to understand if
   * @c 0 is the actual value.
   *
   * @see getNumerator()
   * @see getDenominator()
   */ public
 int getInteger() {
    int ret = libsbmlPINVOKE.ASTNode_getInteger(swigCPtr);
    return ret;
  }

  
/**
   * Returns the value of this node as a string.
   *
   * This function may be called on nodes that (1) are not operators, i.e.,
   * nodes for which @if clike isOperator()@else
   * ASTNode::isOperator()@endif returns @c false, and (2) are not numbers,
   * i.e., @if clike isNumber()@else ASTNode::isNumber()@endif returns
   * @c null.
   *
   * @return the value of this ASTNode as a string, or @c null if it is
   * a node that does not have a name equivalent (e.g., if it is a number).
   */ public
 string getName() {
    string ret = libsbmlPINVOKE.ASTNode_getName(swigCPtr);
    return ret;
  }

  
/**
   * Returns the value of this operator node as a string.
   *
   * This function may be called on nodes that are operators, i.e., nodes for
   * which @if clike isOperator()@else ASTNode::isOperator()@endif returns
   * @c true.
   *
   * @return the name of this operator ASTNode as a string (or @c null if not
   * an operator).
   */ public
 string getOperatorName() {
    string ret = libsbmlPINVOKE.ASTNode_getOperatorName(swigCPtr);
    return ret;
  }

  
/**
   * Returns the value of the numerator of this node if of
   * type @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, or the 
   * numerical value of the node if of type 
   * @link libsbml#AST_INTEGER AST_INTEGER@endlink; @c 0 otherwise.
   *
   * This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink or
   * @link libsbml#AST_INTEGER AST_INTEGER@endlink.
   * It will return @c 0 if the node type is another type, but since @c 0 may
   * be a valid value for the denominator of a rational number or of an integer, it is
   * important to be sure that the node type is the correct type in order to
   * correctly interpret the returned value.
   *
   * @return the value of the numerator of this ASTNode if
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, the value if 
   * @link libsbml#AST_INTEGER AST_INTEGER@endlink, or @c 0 otherwise.
   *
   * @see getDenominator()
   * @see getInteger()
   */ public
 int getNumerator() {
    int ret = libsbmlPINVOKE.ASTNode_getNumerator(swigCPtr);
    return ret;
  }

  
/**
   * Returns the value of the denominator of this node.
   *
   * @return the value of the denominator of this ASTNode, or @c 1 (true) if
   * this node is not of type @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
   *
   * @note This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
   * It will return @c 1 if the node type is another type, but since @c 1 may
   * be a valid value for the denominator of a rational number, it is
   * important to be sure that the node type is the correct type in order to
   * correctly interpret the returned value.
   *
   * @see getNumerator()
   */ public
 int getDenominator() {
    int ret = libsbmlPINVOKE.ASTNode_getDenominator(swigCPtr);
    return ret;
  }

  
/**
   * Returns the real-numbered value of this node.
   *
   * This function performs the necessary arithmetic if the node type is
   * @link libsbml#AST_REAL_E AST_REAL_E@endlink (<em>mantissa *
   * 10<sup>exponent</sup></em>) or
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink
   * (<em>numerator / denominator</em>).
   *
   * @return the value of this ASTNode as a real (double), or @c 0
   * if this is not a node that holds a number.
   *
   * @note This function should be called only when this ASTNode has a
   * numerical value type.  It will return @c 0 if the node type is another
   * type, but since @c 0 may be a valid value, it is important to be sure
   * that the node type is the correct type in order to correctly interpret
   * the returned value.
   */ public
 double getReal() {
    double ret = libsbmlPINVOKE.ASTNode_getReal(swigCPtr);
    return ret;
  }

  
/**
   * Returns the mantissa value of this node.
   *
   * If @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_REAL AST_REAL@endlink, this method is
   * identical to ASTNode::getReal().
   *
   * @return the value of the mantissa of this ASTNode, or @c 0 if this
   * node is not a type that has a real-numbered value.
   *
   * @note This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif returns
   * @link libsbml#AST_REAL_E AST_REAL_E@endlink,
   * @link libsbml#AST_REAL AST_REAL@endlink or
   * @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.  It
   * will return @c 0 if the node type is another type, but since @c 0 may be
   * a valid value, it is important to be sure that the node type is the
   * correct type in order to correctly interpret the returned value.
   *
   * @see getExponent()
   */ public
 double getMantissa() {
    double ret = libsbmlPINVOKE.ASTNode_getMantissa(swigCPtr);
    return ret;
  }

  
/**
   * Returns the exponent value of this ASTNode.
   *
   * @return the value of the exponent of this ASTNode, or @c 0 if this
   * is not a type of node that has an exponent.
   *
   * @note This function should be called only when
   * @if clike getType()@else ASTNode::getType()@endif
   * returns @link libsbml#AST_REAL_E AST_REAL_E@endlink.
   * It will return @c 0 if the node type is another type, but since @c 0 may
   * be a valid value, it is important to be sure that the node type is the
   * correct type in order to correctly interpret the returned value.
   *
   * @see getMantissa()
   */ public
 int getExponent() {
    int ret = libsbmlPINVOKE.ASTNode_getExponent(swigCPtr);
    return ret;
  }

  
/**
   * Returns the numerical value of this ASTNode.
   *
   * @return the numerical value of this ASTNode, or @c NaN if this
   * is not a type of node that has a numerical value.
   *
   * @note This function will return a numerical value (as a double) for 
   * any ASTNode_t that represents a number, a constant such as 
   * @link libsbml#AST_CONSTANT_PI AST_CONSTANT_PI@endlink, 
   * @link libsbml#AST_CONSTANT_E AST_CONSTANT_E@endlink, or 
   * @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink, or 
   * @c 1 for nodes of type 
   * @link libsbml#AST_CONSTANT_TRUE AST_CONSTANT_TRUE@endlink and @c 0 for nodes of type
   * @link libsbml#AST_CONSTANT_FALSE AST_CONSTANT_FALSE@endlink. It does not evaluate
   * the node in any way so, for example, it will not return the value of 
   * a named ASTNode_t or attempt to evaluate a function. 
   * This includes a node representing @c time i.e. nodes
   * of type @link libsbml#AST_NAME_TIME AST_NAME_TIME@endlink.
   */ public
 double getValue() {
    double ret = libsbmlPINVOKE.ASTNode_getValue(swigCPtr);
    return ret;
  }

  
/**
   * Returns the precedence of this node in the infix math syntax of SBML
   * Level&nbsp;1.  For more information about the infix syntax, see the
   * discussion about <a href='#math-convert'>text string formulas</a> at
   * the top of the documentation for ASTNode.
   * 
   * @return an integer indicating the precedence of this ASTNode
   */ public
 int getPrecedence() {
    int ret = libsbmlPINVOKE.ASTNode_getPrecedence(swigCPtr);
    return ret;
  }

  
/**
   * Returns the type of this ASTNode.
   *
   * The value returned is one of the Core AST type codes such as
   * @link libsbml#AST_LAMBDA AST_LAMBDA@endlink,
   * @link libsbml#AST_PLUS AST_PLUS@endlink, etc.
   *
   * @return the type of this ASTNode.
   */ public
 int getType() {
    int ret = libsbmlPINVOKE.ASTNode_getType(swigCPtr);
    return ret;
  }

  
/**
   * Returns the units of this ASTNode.  
   *
   * @htmlinclude about-sbml-units-attrib.html
   * 
   * @return the units of this ASTNode.
   *
   * @note The <code>sbml:units</code> attribute is only available in SBML
   * Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.
   *
   * @see @sbmlfunction{parseL3Formula, String}
   */ public
 string getUnits() {
    string ret = libsbmlPINVOKE.ASTNode_getUnits(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is the special 
   * symbol @c avogadro.  The predicate returns @c false (zero) otherwise.
   * 
   * SBML Level&nbsp;3 introduced a predefined MathML <code>&lt;csymbol&gt;</code>
   * for the value of Avogadro's constant.  LibSBML stores this internally as
   * a node of type @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink.
   * This method returns @c true if this node has that type.
   *
   * @return @c true if this ASTNode is the special symbol avogadro,
   * @c false otherwise.
   *
   * @see @sbmlfunction{parseL3Formula, String}
   */ public
 bool isAvogadro() {
    bool ret = libsbmlPINVOKE.ASTNode_isAvogadro(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node has a Boolean type.
   *
   * The ASTNode objects that have Boolean types are the logical operators,
   * relational operators, and the constants @c true or @c false.
   *
   * @return @c true if this ASTNode has a Boolean type, @c false otherwise.
   */ public
 bool isBoolean() {
    bool ret = libsbmlPINVOKE.ASTNode_isBoolean(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node returns a Boolean type
   * or @c false (zero) otherwise.
   *
   * This function looks at the whole ASTNode rather than just the top 
   * level of the ASTNode. Thus it will consider return values from
   * piecewise statements.  In addition, if this ASTNode uses a function
   * call, the return value of the functionDefinition will be determined.
   * Note that this is only possible where the ASTNode can trace its parent
   * Model, that is, the ASTNode must represent the <code>&lt;math&gt;</code> element of some
   * SBML object that has already been added to an instance of an SBMLDocument.
   * If this is not the case, this function will return @c false unless
   * isBoolean() returns @c true.
   *
   * @see isBoolean()
   *
   * @return @c true if this ASTNode returns a Boolean, @c false otherwise.
   */ public
 bool returnsBoolean(Model model) {
    bool ret = libsbmlPINVOKE.ASTNode_returnsBoolean__SWIG_0(swigCPtr, Model.getCPtr(model));
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node returns a Boolean type
   * or @c false (zero) otherwise.
   *
   * This function looks at the whole ASTNode rather than just the top 
   * level of the ASTNode. Thus it will consider return values from
   * piecewise statements.  In addition, if this ASTNode uses a function
   * call, the return value of the functionDefinition will be determined.
   * Note that this is only possible where the ASTNode can trace its parent
   * Model, that is, the ASTNode must represent the <code>&lt;math&gt;</code> element of some
   * SBML object that has already been added to an instance of an SBMLDocument.
   * If this is not the case, this function will return @c false unless
   * isBoolean() returns @c true.
   *
   * @see isBoolean()
   *
   * @return @c true if this ASTNode returns a Boolean, @c false otherwise.
   */ public
 bool returnsBoolean() {
    bool ret = libsbmlPINVOKE.ASTNode_returnsBoolean__SWIG_1(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents a MathML
   * constant (e.g., @c true, @c Pi).
   * 
   * @return @c true if this ASTNode is a MathML constant, @c false otherwise.
   * 
   * @note this function will also return @c true for nodes of type
   * @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink in SBML Level&nbsp;3.
   */ public
 bool isConstant() {
    bool ret = libsbmlPINVOKE.ASTNode_isConstant(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true (nonzero) if this node represents a MathML
  * ci element representing a value not a function (e.g., @c true, @c Pi).
  *
  * @return @c true if this ASTNode is a MathML ci element, @c false otherwise.
  */ public
 bool isCiNumber() {
    bool ret = libsbmlPINVOKE.ASTNode_isCiNumber(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true (nonzero) if this node represents a MathML
  * constant with numeric value (e.g., @c Pi).
  *
  * @return @c true if this ASTNode is a MathML constant, @c false otherwise.
  *
  * @note this function will also return @c true for 
  * @link libsbml#AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink in SBML Level&nbsp;3.
  */ public
 bool isConstantNumber() {
    bool ret = libsbmlPINVOKE.ASTNode_isConstantNumber(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents a MathML
   * csymbol representing a function.
   *
   * @return @c true if this ASTNode is a MathML csymbol function, @c false otherwise.
   */ public
 bool isCSymbolFunction() {
    bool ret = libsbmlPINVOKE.ASTNode_isCSymbolFunction(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node represents a function.
   *
   * The three types of functions in SBML are MathML functions (e.g.,
   * <code>abs()</code>), SBML Level&nbsp;1 functions (in the SBML
   * Level&nbsp;1 math syntax), and user-defined functions (using
   * FunctionDefinition in SBML Level&nbsp;2 and&nbsp;3).
   *
   * @return @c true if this ASTNode is a function, @c false otherwise.
   */ public
 bool isFunction() {
    bool ret = libsbmlPINVOKE.ASTNode_isFunction(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents
   * the special IEEE 754 value infinity, @c false (zero) otherwise.
   *
   * @return @c true if this ASTNode is the special IEEE 754 value infinity,
   * @c false otherwise.
   */ public
 bool isInfinity() {
    bool ret = libsbmlPINVOKE.ASTNode_isInfinity(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node contains an
   * integer value, @c false (zero) otherwise.
   *
   * @return @c true if this ASTNode is of type @link libsbml#AST_INTEGER AST_INTEGER@endlink, @c false otherwise.
   */ public
 bool isInteger() {
    bool ret = libsbmlPINVOKE.ASTNode_isInteger(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is a MathML
   * <code>&lt;lambda&gt;</code>, @c false (zero) otherwise.
   * 
   * @return @c true if this ASTNode is of type @link libsbml#AST_LAMBDA AST_LAMBDA@endlink, @c false otherwise.
   */ public
 bool isLambda() {
    bool ret = libsbmlPINVOKE.ASTNode_isLambda(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents a 
   * @c log10 function, @c false (zero) otherwise. 
   *
   * More precisely, this predicate returns @c true if the node type is 
   * @link libsbml#AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two
   * children, the first of which is an @link libsbml#AST_INTEGER AST_INTEGER@endlink equal to 10.
   * 
   * @return @c true if the given ASTNode represents a log10() function,
   * @c false otherwise.
   *
   * @see @sbmlfunction{parseL3Formula, String}
   */ public
 bool isLog10() {
    bool ret = libsbmlPINVOKE.ASTNode_isLog10(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is a MathML
   * logical operator.
   *
   * The possible MathML logical operators in SBML core are @c and, @c or, @c not,
   * @c xor, and (as of SBML Level&nbsp;3 Version&nbsp;2) @c implies.  If
   * the node represents a logical operator defined in a Level&nbsp;3 package,
   * it will also return @c true.
   *
   * @return @c true if this ASTNode is a MathML logical operator, @c false
   * otherwise.
   */ public
 bool isLogical() {
    bool ret = libsbmlPINVOKE.ASTNode_isLogical(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node is a user-defined variable name
   * or the symbols for time or Avogadro's constant.
   *
   * SBML Levels&nbsp;2 and&nbsp;3 provides <code>&lt;csymbol&gt;</code>
   * definitions for 'time' and 'avogadro', which can be used to represent
   * simulation time and Avogadro's constant in MathML.  Note that this
   * method does @em not return @c true for the other <code>csymbol</code>
   * values defined by SBML, 'delay', because the 'delay' is a function
   * and not a constant or variable.  Similarly, this function returns
   * @c false for the csymbol functions added by the 'Distributions' package.
   *
   * @return @c true if this ASTNode is a user-defined variable name in SBML
   * or the special symbols for time or Avogadro's constant. It returns
   * @c false otherwise.
   */ public
 bool isName() {
    bool ret = libsbmlPINVOKE.ASTNode_isName(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents the
   * special IEEE 754 value 'not a number' (NaN), @c false (zero)
   * otherwise.
   * 
   * @return @c true if this ASTNode is the special IEEE 754 NaN, @c false
   * otherwise.
   */ public
 bool isNaN() {
    bool ret = libsbmlPINVOKE.ASTNode_isNaN(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents the
   * special IEEE 754 value 'negative infinity', @c false (zero) otherwise.
   * 
   * @return @c true if this ASTNode is the special IEEE 754 value negative
   * infinity, @c false otherwise.
   */ public
 bool isNegInfinity() {
    bool ret = libsbmlPINVOKE.ASTNode_isNegInfinity(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node contains a number,
   * @c false (zero) otherwise.  This is functionally equivalent to the
   * following code:
   * @verbatim
 isInteger() || isReal()
 @endverbatim
   * 
   * @return @c true if this ASTNode is a number, @c false otherwise.
   */ public
 bool isNumber() {
    bool ret = libsbmlPINVOKE.ASTNode_isNumber(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node is a mathematical
   * operator.
   *
   * The possible mathematical operators in the MathML syntax supported by
   * SBML are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>
   * and <code>^</code> (power).
   *
   * @return @c true if this ASTNode is an operator, @c false otherwise.
   */ public
 bool isOperator() {
    bool ret = libsbmlPINVOKE.ASTNode_isOperator(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is the MathML
   * <code>&lt;piecewise&gt;</code> construct.
   * 
   * @return @c true if this ASTNode is a MathML @c piecewise function, 
   * @c false (zero) otherwise.
   */ public
 bool isPiecewise() {
    bool ret = libsbmlPINVOKE.ASTNode_isPiecewise(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents a rational
   * number.
   * 
   * @return @c true if this ASTNode is of type 
   * @link libsbml#AST_RATIONAL AST_RATIONAL@endlink, @c false (zero) otherwise.
   */ public
 bool isRational() {
    bool ret = libsbmlPINVOKE.ASTNode_isRational(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node can represent a
   * real number, @c false (zero) otherwise.
   *
   * More precisely, this node must be of one of the following types: @link libsbml#AST_REAL AST_REAL@endlink, @link libsbml#AST_REAL_E AST_REAL_E@endlink or @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
   *
   * @return @c true if the value of this ASTNode can represented as a real
   * number, @c false otherwise.
   */ public
 bool isReal() {
    bool ret = libsbmlPINVOKE.ASTNode_isReal(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node is a MathML
   * relational operator.
   *
   * The MathML relational operators are <code>==</code>, <code>&gt;=</code>,
   * <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.
   *
   * @return @c true if this ASTNode is a MathML relational operator, @c
   * false otherwise
   */ public
 bool isRelational() {
    bool ret = libsbmlPINVOKE.ASTNode_isRelational(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node represents a
   * square root function, @c false (zero) otherwise.
   *
   * More precisely, the node type must be @link libsbml#AST_FUNCTION_ROOT AST_FUNCTION_ROOT@endlink with two
   * children, the first of which is an @link libsbml#AST_INTEGER AST_INTEGER@endlink node having value equal to 2.
   * 
   * @return @c true if the given ASTNode represents a sqrt() function,
   * @c false otherwise.
   */ public
 bool isSqrt() {
    bool ret = libsbmlPINVOKE.ASTNode_isSqrt(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is a unary minus
   * operator, @c false (zero) otherwise.
   *
   * A node is defined as a unary minus node if it is of type @link libsbml#AST_MINUS AST_MINUS@endlink and has exactly one child.
   *
   * For numbers, unary minus nodes can be 'collapsed' by negating the
   * number.  In fact, @sbmlfunction{parseFormula, String} 
   * does this during its parsing process, and @sbmlfunction{parseL3Formula, String} 
   * has a configuration option that allows this behavior to be turned
   * on or off.  However, unary minus nodes for symbols
   * (@link libsbml#AST_NAME AST_NAME@endlink) cannot
   * be 'collapsed', so this predicate function is necessary.
   * 
   * @return @c true if this ASTNode is a unary minus, @c false otherwise.
   *
   * @see @sbmlfunction{parseL3Formula, String}
   */ public
 bool isUMinus() {
    bool ret = libsbmlPINVOKE.ASTNode_isUMinus(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node is a unary plus
   * operator, @c false (zero) otherwise.  A node is defined as a unary
   * minus node if it is of type @link libsbml#AST_MINUS AST_MINUS@endlink and has exactly one child.
   *
   * @return @c true if this ASTNode is a unary plus, @c false otherwise.
   */ public
 bool isUPlus() {
    bool ret = libsbmlPINVOKE.ASTNode_isUPlus(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true (nonzero) if this node represents a
  * MathML user-defined function.
  *
  * @return @c true if this ASTNode is a user-defined function, @c false otherwise.
  */ public
 bool isUserFunction() {
    bool ret = libsbmlPINVOKE.ASTNode_isUserFunction(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true if this node is of type @p type
  * and has @p numchildren number of children.  Designed
  * for use in cases where it is useful to discover if the node is
  * a unary not or unary minus, or a times node with no children, etc.
  *
  * @return @c true if this ASTNode is has the specified type and number
  *         of children, @c false otherwise.
  */ public
 int hasTypeAndNumChildren(int type, long numchildren) {
    int ret = libsbmlPINVOKE.ASTNode_hasTypeAndNumChildren(swigCPtr, type, numchildren);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node has an unknown type.
   *
   * 'Unknown' nodes have the type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.  
   * Nodes with unknown types will not appear in an
   * ASTNode tree returned by libSBML based upon valid SBML input; the only
   * situation in which a node with type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink 
   * may appear is immediately after having create a
   * new, untyped node using the ASTNode constructor.  Callers creating
   * nodes should endeavor to set the type to a valid node type as soon as
   * possible after creating new nodes.
   * 
   * @return @c true if this ASTNode is of type @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink, @c false otherwise.
   */ public
 bool isUnknown() {
    bool ret = libsbmlPINVOKE.ASTNode_isUnknown(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node has a value for the MathML
   * attribute 'id'.
   *
   * @return @c true if this ASTNode has an attribute id, @c false otherwise.
   *
   * @see isSetClass()
   * @see isSetStyle()
   * @see setId(string id)
   * @see unsetId()
   */ public
 bool isSetId() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetId(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node has a value for the MathML
   * attribute 'class'.
   *
   * @return @c true if this ASTNode has an attribute class, @c false otherwise.
   *
   * @see isSetId()
   * @see isSetStyle()
   * @see @if java setClassName(string id)@else setClass()@endif
   * @see unsetClass()
   */ public
 bool isSetClass() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetClass(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node has a value for the MathML
   * attribute 'style'.
   *
   * @return @c true if this ASTNode has an attribute style, @c false otherwise.
   *
   * @see isSetClass()
   * @see isSetId()
   * @see setStyle(string id)
   * @see unsetStyle()
   */ public
 bool isSetStyle() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetStyle(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node has the attribute
   * <code>sbml:units</code>.
   *
   * @htmlinclude about-sbml-units-attrib.html
   *
   * @return @c true if this ASTNode has units associated with it, @c false otherwise.
   *
   * @note The <code>sbml:units</code> attribute is only available in SBML
   * Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.
   *
   * @see hasUnits()
   * @see setUnits(string units)
   */ public
 bool isSetUnits() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetUnits(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true (nonzero) if this node or any of its
   * children nodes have the attribute <code>sbml:units</code>.
   *
   * @htmlinclude about-sbml-units-attrib.html
   *
   * @return @c true if this ASTNode or its children has units associated
   * with it, @c false otherwise.
   *
   * @note The <code>sbml:units</code> attribute is only available in SBML
   * Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.
   *
   * @see isSetUnits()
   * @see setUnits(string units)
   */ public
 bool hasUnits() {
    bool ret = libsbmlPINVOKE.ASTNode_hasUnits(swigCPtr);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given character.  If character
   * is one of @c +, @c -, <code>*</code>, <code>/</code> or @c ^, the node
   * type will be set accordingly.  For all other characters, the node type
   * will be set to @link libsbml#AST_UNKNOWN AST_UNKNOWN@endlink.
   *
   * @param value the character value to which the node's value should be
   * set.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setCharacter(char value) {
    int ret = libsbmlPINVOKE.ASTNode_setCharacter(swigCPtr, value);
    return ret;
  }

  
/**
   * Sets the MathML attribute @c id of this ASTNode.
   *
   * @param id @c string representing the identifier.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   *
   * @see isSetId()
   * @see getId()
   * @see unsetId()
   */ public
 int setId(string id) {
    int ret = libsbmlPINVOKE.ASTNode_setId(swigCPtr, id);
    return ret;
  }

  
/**
   * Sets the MathML attribute @c class of this ASTNode to @p className.
   *
   * @param className @c string representing the MathML class for this node.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   *
   * @if java
   * @note In the API interfaces for languages other than Java, this method
   * is named <code>setClass()</code>, but in Java it is renamed
   * <code>setClassName()</code> to avoid a name collision with Java's
   * standard object method of the same name.
   * @endif
   *
   * @see isSetClass()
   * @see getClass()
   * @see unsetClass()
   */ public
 int setClass(string className) {
    int ret = libsbmlPINVOKE.ASTNode_setClass(swigCPtr, className);
    return ret;
  }

  
/**
   * Sets the MathML attribute @c style of this ASTNode to style.
   *
   * @param style @c string representing the identifier.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   *
   * @see isSetStyle()
   * @see getStyle()
   * @see unsetStyle()
   */ public
 int setStyle(string style) {
    int ret = libsbmlPINVOKE.ASTNode_setStyle(swigCPtr, style);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given name.
   *
   * As a side effect, this ASTNode object's type will be reset to
   * @link libsbml#AST_NAME AST_NAME@endlink if (and <em>only
   * if</em>) the ASTNode was previously an operator (
   * @if clike isOperator()@else ASTNode::isOperator()@endif
   * <code>== true</code>), number (
   * @if clike isNumber()@else ASTNode::isNumber()@endif
   * <code>== true</code>), or unknown.
   * This allows names to be set for @link libsbml#AST_FUNCTION AST_FUNCTION@endlink nodes and the like.
   *
   * @param name the string containing the name to which this node's value
   * should be set.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setName(string name) {
    int ret = libsbmlPINVOKE.ASTNode_setName(swigCPtr, name);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given (@c long) integer and sets
   * the node type to @link libsbml#AST_INTEGER AST_INTEGER@endlink.
   *
   * @param value the integer to which this node's value should be set.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setValue(int value) {
    int ret = libsbmlPINVOKE.ASTNode_setValue__SWIG_0(swigCPtr, value);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given rational in two parts: the
   * numerator and denominator.  The node type is set to @link libsbml#AST_RATIONAL AST_RATIONAL@endlink.
   *
   * @param numerator the numerator value of the rational.
   * @param denominator the denominator value of the rational.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setValue(int numerator, int denominator) {
    int ret = libsbmlPINVOKE.ASTNode_setValue__SWIG_1(swigCPtr, numerator, denominator);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given real (@c double) and sets
   * the node type to @link libsbml#AST_REAL AST_REAL@endlink.
   *
   * This is functionally equivalent to:
   * @verbatim
setValue(value, 0);
@endverbatim
   *
   * @param value the @c double format number to which this node's value
   * should be set.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setValue(double value) {
    int ret = libsbmlPINVOKE.ASTNode_setValue__SWIG_2(swigCPtr, value);
    return ret;
  }

  
/**
   * Sets the value of this ASTNode to the given real (@c double) in two
   * parts: the mantissa and the exponent.  The node type is set to
   * @link libsbml#AST_REAL_E AST_REAL_E@endlink.
   *
   * @param mantissa the mantissa of this node's real-numbered value.
   * @param exponent the exponent of this node's real-numbered value.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif This particular
 * function only does one thing irrespective of user input or 
 * object state, and thus will only return a single value:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   */ public
 int setValue(double mantissa, int exponent) {
    int ret = libsbmlPINVOKE.ASTNode_setValue__SWIG_3(swigCPtr, mantissa, exponent);
    return ret;
  }

  
/**
   * Sets the type of this ASTNode to the given type code.
   *
   * @param type the type to which this node should be set.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
   *
   * @note A side-effect of doing this is that any numerical values previously
   * stored in this node are reset to zero.
   */ public
 int setType(int type) {
    int ret = libsbmlPINVOKE.ASTNode_setType(swigCPtr, type);
    return ret;
  }

  
/**
   * Sets the units of this ASTNode to units.
   *
   * The units will be set @em only if this ASTNode object represents a
   * MathML <code>&lt;cn&gt;</code> element, i.e., represents a number.
   * Callers may use
   * @if clike isNumber()@else ASTNode::isNumber()@endif
   * to inquire whether the node is of that type.
   *
   * @htmlinclude about-sbml-units-attrib.html
   *
   * @param units @c string representing the unit identifier.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
   * @li @link libsbml#LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink
   *
   * @note The <code>sbml:units</code> attribute is only available in SBML
   * Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.
   *
   * @see isSetUnits()
   * @see hasUnits()
   */ public
 int setUnits(string units) {
    int ret = libsbmlPINVOKE.ASTNode_setUnits(swigCPtr, units);
    return ret;
  }

  
/**
   * Swaps the children of this ASTNode object with the children of the
   * given ASTNode object.
   *
   * @param that the other node whose children should be used to replace
   * <em>this</em> node's children.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   */ public
 int swapChildren(ASTNode that) {
    int ret = libsbmlPINVOKE.ASTNode_swapChildren(swigCPtr, ASTNode.getCPtr(that));
    return ret;
  }

  
/**
   * Renames all the SIdRef attributes on this node and any child node
   */ public new
 void renameSIdRefs(string oldid, string newid) {
    libsbmlPINVOKE.ASTNode_renameSIdRefs(swigCPtr, oldid, newid);
  }

  
/**
   * Renames all the UnitSIdRef attributes on this node and any child node.
   *
   * The only place UnitSIDRefs appear is in MathML <code>&lt;cn&gt;</code>
   * elements, so the effects of this method are limited to that.
   *
   * @param oldid the old identifier.
   * @param newid the new identifier.
   */ public new
 void renameUnitSIdRefs(string oldid, string newid) {
    libsbmlPINVOKE.ASTNode_renameUnitSIdRefs(swigCPtr, oldid, newid);
  }

  
/** */ /* libsbml-internal */ public new
 void replaceIDWithFunction(string id, ASTNode function) {
    libsbmlPINVOKE.ASTNode_replaceIDWithFunction(swigCPtr, id, ASTNode.getCPtr(function));
  }

  
/** */ /* libsbml-internal */ public new
 void multiplyTimeBy(ASTNode function) {
    libsbmlPINVOKE.ASTNode_multiplyTimeBy(swigCPtr, ASTNode.getCPtr(function));
  }

  
/**
   * Unsets the units of this ASTNode.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   */ public
 int unsetUnits() {
    int ret = libsbmlPINVOKE.ASTNode_unsetUnits(swigCPtr);
    return ret;
  }

  
/**
   * Unsets the MathML @c id attribute of this ASTNode.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   */ public
 int unsetId() {
    int ret = libsbmlPINVOKE.ASTNode_unsetId(swigCPtr);
    return ret;
  }

  
/**
   * Unsets the MathML @c class attribute of this ASTNode.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   */ public
 int unsetClass() {
    int ret = libsbmlPINVOKE.ASTNode_unsetClass(swigCPtr);
    return ret;
  }

  
/**
   * Unsets the MathML @c style attribute of this ASTNode.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   */ public
 int unsetStyle() {
    int ret = libsbmlPINVOKE.ASTNode_unsetStyle(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 int setDefinitionURL(XMLAttributes url) {
    int ret = libsbmlPINVOKE.ASTNode_setDefinitionURL__SWIG_0(swigCPtr, XMLAttributes.getCPtr(url));
    if (libsbmlPINVOKE.SWIGPendingException.Pending) throw libsbmlPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 int setDefinitionURL(string url) {
    int ret = libsbmlPINVOKE.ASTNode_setDefinitionURL__SWIG_1(swigCPtr, url);
    return ret;
  }

  
/**
   * Returns the MathML @c definitionURL attribute value.
   *
   * @return the value of the @c definitionURL attribute, in the form of
   * a libSBML XMLAttributes object.
   *
   * @see setDefinitionURL(XMLAttributes url)
   * @see setDefinitionURL(string url)
   * @see getDefinitionURLString()
   */ public
 XMLAttributes getDefinitionURL() {
    global::System.IntPtr cPtr = libsbmlPINVOKE.ASTNode_getDefinitionURL(swigCPtr);
    XMLAttributes ret = (cPtr == global::System.IntPtr.Zero) ? null : new XMLAttributes(cPtr, false);
    return ret;
  }

  
/**
   * Replaces occurrences of a given name with a given ASTNode.
   *
   * For example, if the formula in this ASTNode is <code>x + y</code>,
   * and the function is called with @c bvar = @c 'x' and @c arg = an ASTNode
   * representing the real value @c 3.  This method would substitute @c 3 for
   * @c x within this ASTNode object, resulting in the forula <code>3 + y</code>.
   *
   * @param bvar a string representing the variable name to be substituted.
   * @param arg an ASTNode representing the name/value/formula to use as
   * a replacement.
   */ public
 void replaceArgument(string bvar, ASTNode arg) {
    libsbmlPINVOKE.ASTNode_replaceArgument(swigCPtr, bvar, ASTNode.getCPtr(arg));
  }

  
/**
   * Returns the parent SBML object.
   * 
   * @return the parent SBML object of this ASTNode.
   *
   * @see isSetParentSBMLObject()
   * @if clike @see setParentSBMLObject()@endif
   * @see unsetParentSBMLObject()
   */ public
 SBase getParentSBMLObject() {
	SBase ret = (SBase) libsbml.DowncastSBase(libsbmlPINVOKE.ASTNode_getParentSBMLObject(swigCPtr), false);
	return ret;
}

  
/**
   * Unsets the parent SBML object.
   *
   *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
   * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
   *
   * @see isSetParentSBMLObject()
   * @see getParentSBMLObject()
   * @if clike @see setParentSBMLObject()@endif
   */ public
 int unsetParentSBMLObject() {
    int ret = libsbmlPINVOKE.ASTNode_unsetParentSBMLObject(swigCPtr);
    return ret;
  }

  
/**
   * Returns @c true if this node has a value for the parent SBML
   * object.
   *
   * @return @c true if this ASTNode has an parent SBML object set, @c false otherwise.
   *
   * @see getParentSBMLObject()
   * @if clike @see setParentSBMLObject()@endif
   * @see unsetParentSBMLObject()
   */ public
 bool isSetParentSBMLObject() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetParentSBMLObject(swigCPtr);
    return ret;
  }

  
/**
   * Reduces this ASTNode to a binary tree.
   *
   * Example: if this ASTNode is <code>and(x, y, z)</code>, then the
   * formula of the reduced node is <code>and(and(x, y), z)</code>.  The
   * operation replaces the formula stored in the current ASTNode object.
   */ public
 void reduceToBinary() {
    libsbmlPINVOKE.ASTNode_reduceToBinary(swigCPtr);
  }

  
/**
  * Unsets the user data of this node.
  *
  * The user data can be used by the application developer to attach custom
  * information to the node.  In case of a deep copy, this attribute will
  * passed as it is. The attribute will be never interpreted by this class.
  *
  *
 * @return integer value indicating success/failure of the
 * function.  @if clike The value is drawn from the
 * enumeration #OperationReturnValues_t. @endif The possible values
 * returned by this function are:
 * @li @link libsbml#LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink
  * @li @link libsbml#LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink
  *
  * @if clike
  * @see setUserData()
  * @see getUserData()
  * @see isSetUserData()
  * @endif
  */ public
 int unsetUserData() {
    int ret = libsbmlPINVOKE.ASTNode_unsetUserData(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true if this node has a user data object.
  *
  * @return @c true if this ASTNode has a user data object set, @c false
  * otherwise.
  *
  * @if clike
  * @see setUserData()
  * @see getUserData()
  * @see unsetUserData()
  * @endif
  */ public
 bool isSetUserData() {
    bool ret = libsbmlPINVOKE.ASTNode_isSetUserData(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true or @c false depending on whether this
  * ASTNode is well-formed.
  *
  * @note An ASTNode may be well-formed, with each node and its children
  * having the appropriate number of children for the given type, but may
  * still be invalid in the context of its use within an SBML model.
  *
  * @return @c true if this ASTNode is well-formed, @c false otherwise.
  *
  * @see hasCorrectNumberArguments()
  */ public
 bool isWellFormedASTNode() {
    bool ret = libsbmlPINVOKE.ASTNode_isWellFormedASTNode(swigCPtr);
    return ret;
  }

  
/**
  * Returns @c true if this ASTNode has the correct number of children for
  * its type.
  *
  * For example, an ASTNode with type @link libsbml#AST_MINUS AST_MINUS@endlink
  * expects 1 or 2 child nodes.
  *
  * @return @c true if this ASTNode has the appropriate number of children
  * for its type, @c false otherwise.
  *
  * @note This function performs a check on the top-level node only.  Child
  * nodes are not checked.
  *
  * @see isWellFormedASTNode()
  */ public
 bool hasCorrectNumberArguments() {
    bool ret = libsbmlPINVOKE.ASTNode_hasCorrectNumberArguments(swigCPtr);
    return ret;
  }

  
/**
   * Returns the MathML @c definitionURL attribute value as a string.
   *
   * @return the value of the @c definitionURL attribute, as a string.
   *
   * @see getDefinitionURL()
   * @see setDefinitionURL(string url)
   * @see setDefinitionURL(XMLAttributes url)
   */ public
 string getDefinitionURLString() {
    string ret = libsbmlPINVOKE.ASTNode_getDefinitionURLString(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 bool representsBvar() {
    bool ret = libsbmlPINVOKE.ASTNode_representsBvar(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 bool isBvar() {
    bool ret = libsbmlPINVOKE.ASTNode_isBvar(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 void setBvar() {
    libsbmlPINVOKE.ASTNode_setBvar(swigCPtr);
  }

  
/** */ /* libsbml-internal */ public
 bool usesL3V2MathConstructs() {
    bool ret = libsbmlPINVOKE.ASTNode_usesL3V2MathConstructs(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 bool usesRateOf() {
    bool ret = libsbmlPINVOKE.ASTNode_usesRateOf(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public new
 bool isQualifier() {
    bool ret = libsbmlPINVOKE.ASTNode_isQualifier(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public new
 bool isSemantics() {
    bool ret = libsbmlPINVOKE.ASTNode_isSemantics(swigCPtr);
    return ret;
  }

  
/** */ /* libsbml-internal */ public
 long getNumBvars() { return (long)libsbmlPINVOKE.ASTNode_getNumBvars(swigCPtr); }

  
/** */ /* libsbml-internal */ public
 void addPlugin(ASTBasePlugin plugin) {
    libsbmlPINVOKE.ASTNode_addPlugin(swigCPtr, ASTBasePlugin.getCPtr(plugin));
  }

  
/** */ /* libsbml-internal */ public
 void loadASTPlugins(SBMLNamespaces sbmlns) {
    libsbmlPINVOKE.ASTNode_loadASTPlugins(swigCPtr, SBMLNamespaces.getCPtr(sbmlns));
  }

  
/** */ /* libsbml-internal */ public
 void loadASTPlugin(string pkgName) {
    libsbmlPINVOKE.ASTNode_loadASTPlugin(swigCPtr, pkgName);
  }

  
/**
   * Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
   * package extension with the given @p sbmlns.
   *
   * @param sbmlns the namespace of the plugin to return.
   *
   * @return the plug-in object (the libSBML extension interface) of
   * a package extension with the given package name or URI, or @c null
   * if none exist.
   */ public
 ASTBasePlugin getASTPlugin(SBMLNamespaces sbmlns) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getASTPlugin__SWIG_0(swigCPtr, SBMLNamespaces.getCPtr(sbmlns)), false);
        return ret;
}

  
/**
   * Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
   * package extension for the package that defines the given @p type.
   *
   * @param type the @if clike #ASTNodeType_t@else type@endif that is defined by the given plugin.
   *
   * @return the plug-in object (the libSBML extension interface) of
   * a package extension that defines the given @p type, or @c null
   * if none exist.
   */ public
 ASTBasePlugin getASTPlugin(int type) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getASTPlugin__SWIG_1(swigCPtr, type), false);
        return ret;
}

  
/**
   * Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
   * package extension for the package with the given constraints.
   *
   * @param name the type or csymbol defined by the returned plugin.
   * @param isCsymbol Boolean indicator of whether the @p name is a csymbol
   * (if @c true) or type (if @c false).
   * @param strCmpIsCaseSensitive whether to search for the matching type
   * or csymbol in case-sensitve manner (if @c true) or case-insensitive
   * manner (if @c false).
   *
   * @return the plug-in object (the libSBML extension interface) of
   * a package extension that defines the given @p name, or @c null
   * if none exist.
   */ public
 ASTBasePlugin getASTPlugin(string name, bool isCsymbol, bool strCmpIsCaseSensitive) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getASTPlugin__SWIG_2(swigCPtr, name, isCsymbol, strCmpIsCaseSensitive), false);
        return ret;
}

  
/**
   * Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
   * package extension for the package with the given constraints.
   *
   * @param name the type or csymbol defined by the returned plugin.
   * @param isCsymbol Boolean indicator of whether the @p name is a csymbol
   * (if @c true) or type (if @c false).
   * @param strCmpIsCaseSensitive whether to search for the matching type
   * or csymbol in case-sensitve manner (if @c true) or case-insensitive
   * manner (if @c false).
   *
   * @return the plug-in object (the libSBML extension interface) of
   * a package extension that defines the given @p name, or @c null
   * if none exist.
   */ public
 ASTBasePlugin getASTPlugin(string name, bool isCsymbol) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getASTPlugin__SWIG_3(swigCPtr, name, isCsymbol), false);
        return ret;
}

  
/**
   * Returns a plug-in object (extension interface) for an SBML Level&nbsp;3
   * package extension for the package with the given constraints.
   *
   * @param name the type or csymbol defined by the returned plugin.
   * @param isCsymbol Boolean indicator of whether the @p name is a csymbol
   * (if @c true) or type (if @c false).
   * @param strCmpIsCaseSensitive whether to search for the matching type
   * or csymbol in case-sensitve manner (if @c true) or case-insensitive
   * manner (if @c false).
   *
   * @return the plug-in object (the libSBML extension interface) of
   * a package extension that defines the given @p name, or @c null
   * if none exist.
   */ public
 ASTBasePlugin getASTPlugin(string name) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getASTPlugin__SWIG_4(swigCPtr, name), false);
        return ret;
}

  
/** */ /* libsbml-internal */ public
 ASTBasePlugin getPlugin(string package) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getPlugin__SWIG_0(swigCPtr, package), false);
        return ret;
}

  
/** */ /* libsbml-internal */ public
 ASTBasePlugin getPlugin(long n) {
        ASTBasePlugin ret = (ASTBasePlugin) libsbml.DowncastASTBasePlugin(libsbmlPINVOKE.ASTNode_getPlugin__SWIG_2(swigCPtr, n), false);
        return ret;
}

  
/** */ /* libsbml-internal */ public
 long getNumPlugins() { return (long)libsbmlPINVOKE.ASTNode_getNumPlugins(swigCPtr); }

  public ASTNodeList getListOfNodes() {
    ASTNodeList ret = new ASTNodeList(libsbmlPINVOKE.ASTNode_getListOfNodes(swigCPtr), true);
    return ret;
  }

}

}
